(:fib
 (:fib 0 2
  ((mem rsp 0) <- rbx)
  ((mem rsp 8) <- r12)
  (r12 <- 89)  ;; fib number to compute; this is 44 in reality
  (rsi <- 3)   ;; set up args to allocate
  (rdi <- r12) ;; set up args to allocate
  (call allocate 2)
  (rdi <- rax) ;; save this register for the array base pointer 
  (rbx <- 5)   ;; loop index variable, starts at 2 (encoded as 5).
  
  :loop
  (cjump rbx < r12 :keep_going :done)
  :keep_going
  
  ;; compute a[rbx-2], putting it into edx
  (rdx <- rbx)
  (rdx -= 4)   ;; - decrement by 2. 
  (rdx -= 1)   ;; - convert a 2a+1 number into 
  (rdx *= 4)   ;;     8a for the index calculation
  (rdx += rdi) ;; - add in the base pointer
  (rdx += 8)   ;; - skip past the size word
  (rdx <- (mem rdx 0))
  
  ;; compute a[rbx-1], putting it into ecx
  (rcx <- rbx)
  (rcx -= 2)    ;; - decrement by 1.
  (rcx -= 1)    ;; - convert a 2a+1 number into
  (rcx *= 4)    ;;      8a for the index calculation
  (rcx += rdi)  ;; - add in the base pointer
  (rcx += 8)    ;; - skip past the size word
  (rcx <- (mem rcx 0))
  
  ;; put the sum of a[ebx-2]+a[ebx-1] into edx
  (rdx += rcx)
  (rdx -= 1) ;; number conversion...
  
  ;; compute the location of a[ebx], putting it into ecx
  (rcx <- rbx)
  (rcx -= 1)   ;; - convert a 2a+1 number into 
  (rcx *= 4)   ;;     8a for the index calculation
  (rcx += 8)   ;; - skip past the size word
  (rcx += rdi) ;; - add in the base pointer 
  
  ;; store the sum a[ebx-2]+a[ebx-1] into a[ebx]
  ((mem rcx 0) <- rdx)
  
  ;; increment the loop counter
  (rbx += 2) ;; this is what adding by one is.
  
  ;; go back to the loop test
  (goto :loop)
  
  :done
  (call print 1)
  (rbx <- (mem rsp 0))
  (r12 <- (mem rsp 8))
  (return))))